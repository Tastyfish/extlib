local db = {}
local query = {}

--------------------------------
-- Protocol handlers
--------------------------------

local protocols = {
}

for _,ppath in ipairs(fs.find("extlib/dbp/*")) do
	local pname = ppath:match("^extlib/dbp/([^%.].*)$")
	if pname then
		local fn, err = loadfile(ppath)
		if not fn then
			error(err)
		end
		local env = {
			db = db,
			query = query
		}
		setmetatable(env, { __index = _G })
		setfenv(fn, env)
		protocols[pname] = fn()
	end
end

-- Generic functions to filter to protocol

local function resolvePath(path)
	local protocol, name = path:match("^%w+:.+$")
	if not protocol then
		protocol = "file"
		name = path
	end
	return protocol, name
end

-- does database exist
function exists(path)
	local protocol, name = resolvePath(path)
	
	return protocols[protocol].exists(name)
end

-- reads database-general data, self is query
local function loadIndex(self)
	self.db.p.loadIndex(self)
end

-- writes database-general data, self is query
local function saveIndex(self)
	self.db.p.saveIndex(self)
end

-- reads a row of data by index, as an iterator fn
local function readDBRow(self, prevE)
	if self.rowID >= self.rowCount then
		return nil
	end
	
	self.rowID = self.rowID + 1
	
	local rt = {}
	-- set __row interal field
	rt.__row = {value = self.rowID}
	setmetatable(rt.__row, self.db.types.number)
	
	self.db.p.readDBRow(self, rt)
	
	return rt
end

-- writes a row back to db
local function writeDBRow(self, row)
	self.db.p.writeDBRow(self, row)
end

-- delete a row just by ID #
local function deleteDBRow(self, rowID)
	self.db.p.deleteDBRow(self, rowID)
end

local function acquireWrite(self)
	self.db.p.acquireWrite(self)
end

local function releaseWrite(self)
	self.db.p.releaseWrite(self)
end

local function acquireRead(self)
	self.db.p.acquireRead(self)
end

local function releaseRead(self)
	self.db.p.releaseRead(self)
end

--------------------------------
-- DB Class
--------------------------------

function open(path)
	if not exists(path) then
		error("Database at "..path.." does not exist.", 2)
	end
	
	local protocol, name = resolvePath(path)
	
	local fields = protocols[protocol].open(name)
	
	local d = {
		path = name,
		fields = fields,
		p = protocols[protocol]
	}
	setmetatable(d, {
		__index = db,
		__call = db.query
	})
	return d
end

function create(path, fmt)
	if exists(path) then
		error("Database at "..path.." already exists.", 2)
	end
	
	local protocol, name = resolvePath(path)
	
	protocols[protocol].create(name, fmt)
	
	return open(path)
end

function openOrCreate(path, fmt)
	return exists(path) and
		open(path) or
		create(path, fmt)
end

function db:createField(tname, value)
	local v = {}
	setmetatable(v, self.types[tname])
	-- and run value through type parser
	v(value)
	return v
end

-- insert a row into db
function db:insert(row)
	-- verify fields
	for _,f in ipairs(self.fields) do
		row[f[1]] = self:createField(f[2], row[f[1]])
	end
	
	-- init query
	local q = self:query()
	
	acquireWrite(q)
	loadIndex(q)
		
	-- assign last row id
	row.__row = self:createField("number", q.rowCount + 1)
	
	-- write new entry
	writeDBRow(q, row)
	
	-- update row count
	q.rowCount = q.rowCount + 1
	saveIndex(q)
	releaseWrite(q)
end

-- field types
db.types = {number = {}, string = {}, date = {}}
db.type__base = {}

function db.type__base.__concat(a, b)
	return tostring(a) .. tostring(b)
end

function db.type__base.__lt(a, b)
	if type(a) == "table" then a = a.value end
	if type(b) == "table" then b = b.value end
	return a < b
end

function db.type__base.__len(a)
	return #a.value
end

for _,t in pairs(db.types) do
	for k,v in pairs(db.type__base) do
		t[k] = v
	end
end

function db.types.number.__tostring(a)
	return tostring(a.value)
end

function db.types.number.__call(a, v)
	a.value = tonumber(v)
end

function db.types.string.__tostring(a)
	return a.value
end

function db.types.string.__call(a, v)
	a.value = tostring(v)
end

function db.types.date.__tostring(a)
	return ("%d %d:%d"):format(
		math.floor(a.value / 24),
		math.floor(a.value % 24),
		math.floor((a.value * 60) % 60))
end

function db.types.date.__lt(a, b)
	if type(a) == "table" then a = a.value end
	if type(b) == "table" then b = b.value end
	return a < b
end

function db.types.date.__call(a, v)
	local t = type(v)
	if t == "string" then
		local day, hour, min = v:match("(%d+) (%d+):(%d+)")
		a.value = tonumber(day) * 24 + tonumber(hour) + tonumber(min) / 60
	elseif t == "number" then
		a.value = v
	else
		error(("Cannot convert %s to a date."):format(v))
	end
end

--------------------------------
-- Query Class
--------------------------------

local function rootSelector(self, prevE)
	local rv = { readDBRow(self, prevE) }
	if not rv[1] then
		if self.writing then
			releaseWrite(self)
		else
			releaseRead(self)
		end
	end
	return unpack(rv)
end

function db:query(...)
	if (...) then
		return self:query():where(...)
	end
	
	local q = {
		db = self,
		selector = rootSelector
	}
	setmetatable(q, {
		__index = query
	})
	return q
end

-- self is the main iterator
function query:iterate()
	acquireRead(self)
	loadIndex(self)
	self.rowID = 0
	self.writing = false
	
	return self.selector, self, 0
end

function query:writeIterate()
	acquireWrite(self)
	loadIndex(self)
	self.rowID = 0
	self.writing = true
	
	return self.selector, self, 0
end

local _selection = {}
local _superSelection = {}

-- list of fields to return in each row table in the return table
--  if only 1 field, returns a table of those field values
-- OR
--  if the parameter is a function, it's projected via the function
function query:select(...)
	local lst = {}
	
	if ... and type(...) == "function" then
		local fn = ...
		
		for e in self:iterate() do
			local pass, result = pcall(fn, e)
			if not pass then
				error("Error executing selector fn: "..result, 2)
			end
			table.insert(lst, result)
		end
	else
		local fields = {...}	
		
		for e in self:iterate() do
			if #fields > 1 then			
				local filteredE = {}
				for _,v in ipairs(fields) do
					filteredE[v] = e[v]
				end
				
				table.insert(lst, filteredE)
			elseif #fields == 1 then
				table.insert(lst, e[fields[1]])
			else
				table.insert(lst, e)
			end
		end
	end
	
	setmetatable(lst, {__index = _superSelection})
	return lst
end

function query:selectFirst()
	-- do full iteration cycle for conformance reasons
	local retval = nil
	for e in self:iterate() do
		setmetatable(e, {__index = _selection})
		if not retval then
			retval = e
		end
	end
	return retval
end

function query:selectLast()
	-- do full iteration cycle to get last item
	local retval = nil
	for e in self:iterate() do
		setmetatable(e, {__index = _selection})
		retval = e
	end
	return retval
end

function _superSelection:values()
	local vtab = {}
	for i,ie in ipairs(self) do
		local e = {}
		for k,v in pairs(ie) do
			e[k] = v.value
		end
		vtab[i] = e
	end
	return vtab
end

function _selection:values()
	local vtab = {}
	for k,v in pairs(self) do
		vtab[k] = v.value
	end
	return vtab
end

-- update the given fields with the given values in tab
function query:update(tab)
	for e in self:writeIterate() do
		-- verify fields
		for k,v in pairs(tab) do
			for _,f in ipairs(self.db.fields) do
				if f[1] == k then
					e[k] = self.db:createField(f[2], v)
				end
			end
		end
		
		writeDBRow(self, e)
	end
end

-- delete all of the items iterated
function query:delete()
	for e in self:writeIterate() do
		local delID = e.__row.value
		
		if delID ~= self.rowCount then
			-- take last entry and place in this slot
			self.rowID = self.rowCount - 1
			local lastE = readDBRow(self, 0)
			lastE.__row(delID)
			writeDBRow(self, lastE)
		end
		
		-- delete the last, now irrelevent row
		deleteDBRow(self, self.rowCount)
		
		-- update row count
		self.rowCount = self.rowCount - 1
		saveIndex(self)
		
		-- rewind iterator to check the one we just moved
		self.rowID = delID - 1
	end
end

function query:where(test, ...)
	local params = {...}
	
	local testfn, err
	if type(test) == "string" then
		testfn = test:gsub("%$([%a_][%a%d_]*)", "(_row.%1.value)")
		testfn = testfn:gsub("%?", function(s)
			local typeHandler
			typeHandler = {
				string = function()
					return ("(%q)"):format(params[1])
				end,
				number = function()
					return ("(%f)"):format(params[1])
				end,
				table = function()
					if params[1].value ~= nil then
						params[1] = params[1].value
						return typeHandler[type(params[1])]()
					else
						return nil
					end
				end
			}
			local v = typeHandler[type(params[1])]()
			table.remove(params, 1)
			return v
		end)
		
		testfn, err = loadstring("local _row = ...; return ("..testfn..")", testfn)
		if not testfn then
			error(err, 2)
		end
	else
		error("Query must be a string containing query code.", 2)
	end
	
	local psel = self.selector
	self.selector = function(s, e)
		repeat
			e = psel(s, e)
			if not e then
				return nil
			end
		until testfn(e)
		return e
	end
	
	return self
end

-- skip [count] rows
function query:skip(count)
	local psel = self.selector
	self.selector = function(s, e)
		for i = 0, count do
			e = psel(s, e)
			if not e then
				return nil
			end
		end
		count = 0
		return e
	end
	
	return self
end

-- take only up to [count] items, then stop
function query:take(count)
	local psel = self.selector
	self.selector = function(s, e)
		if count == 0 then
			return nil
		end
		count = count - 1
		return psel(s, e)
	end
	
	return self
end

function query:sortByAscending(field)
	local es = self:select(field, "__row")
	table.sort(es, function(a, b)
			return a[field] < b[field]
		end)
	
	local tf, ts, tv = ipairs(es)
	
	self.selector = function(s, e)
		tv, e = tf(ts, tv)
		if not tv then
			if self.writing then
				releaseWrite(self)
			else
				releaseRead(self)
			end
			return nil
		end
		
		-- must be e-1 because it's an iterator fn (expects prev value)
		self.rowID = e.__row.value - 1
		return readDBRow(self, 0)
	end
	
	return self
end

function query:sortByDescending(field)
	local es = self:select(field, "__row")
	table.sort(es, function(a, b)
			return a[field] > b[field]
		end)
	
	local tf, ts, tv = ipairs(es)
	
	self.selector = function(s, e)
		tv, e = tf(ts, tv)
		if not tv then
			if self.writing then
				releaseWrite(self)
			else
				releaseRead(self)
			end
			return nil
		end
		
		-- must be e-1 because it's an iterator fn (expects prev value)
		self.rowID = e.__row.value - 1
		return readDBRow(self, 0)
	end
	
	return self
end